### Соединение INNER

***Это внутреннее соединение, при котором в результирующий набор данных попадут все записи,
которые полностью соответствуют связи, т.е. общим столбцам двух источников.***

-- Соединение INNER
```
SELECT g.product_name,
c.category_name,
g.price
FROM goods AS g
INNER JOIN categories AS c ON g.category = c.category_id;
```

***Перед словом JOIN мы указали слово INNER, которое говорит серверу, что объединение будет внутреннее, т.е. по полному совпадению.
Ключевое слово ON задает условие объединения, т.е. именно здесь Вы указываете, как будет происходить объединение,
по каким столбцам или выражениям.
В данном случае столбец, по которому мы объединяем таблицы, – это идентификатор категории (category_id),
так как он есть в обеих таблицах.***

### Соединение LEFT

***Это левое внешнее соединение, при котором возвращаются все записи из таблицы слева,
даже если записей в правой таблице не существует. В случаях, когда условие не выполняется
и в правой таблице нет соответствующих записей, в результирующий набор данных от правой таблицы
попадают строки с неопределённым значением. Другими словами, если Вам нужно получить все записи одной таблицы
и, если есть, соответствующие записи в другой, то Вы можете использовать объединение LEFT.
Если в таком случае использовать INNER, то Вам вернутся только записи, которые объединены в соответствии с условием,
т.е. если нет соответствующих записей в таблице справа, то записи слева тоже не вернутся.***

-- Соединение LEFT
```
SELECT g.product_name,
c.category_name,
g.price
FROM goods AS g
LEFT JOIN categories AS c ON g.category = c.category_id;
```

### Соединение RIGHT

***Это правое внешнее соединение, работает точно так же, как и LEFT, только для правой таблицы.
Иными словами, возвращаются все записи из правой таблицы и соответствующие записи из левой.
Если записи в левой таблице отсутствуют, то их значения в результирующем наборе заполняются неопределенными значениями.***

-- Соединение RIGHT
```
SELECT g.product_name,
c.category_name,
g.price
FROM goods AS g
RIGHT JOIN categories AS c ON g.category = c.category_id;
```

### Соединение FULL

***Полное внешнее соединение, в данном случае возвращаются все записи как из левой, так и из правой таблицы,
даже если условие не выполняется. Все записи, для которых не нашлось совпадения в соседней таблице,
заполняются неопределенными значениями. Это своего рода объединение и LEFT, и RIGHT, которое применили в одном объединении.***
```
-- Соединение FULL
SELECT g.product_name,
       c.category_name,
       g.price
FROM goods AS g
FULL JOIN categories AS c ON g.category = c.category_id;
```

### Соединение CROSS

***Но на самом деле это не так, принцип его работы очень прост, каждая строка из одной таблицы объединяется со всеми
строками в другой таблице. Таким образом, происходит перемножение количества строк в этих таблицах,
в итоге результирующий набор будет содержать как раз количество записей, которое будет равняться произведению
количества строк в первой таблице на количество строк во второй таблице.
Ключевое слово ON в данном виде соединения указывать не требуется.***

### UNION

***Вы уже познакомились с объединениями JOIN, которые формируют результирующий набор данных за счет объединения таблиц
в одной инструкции SELECT. Однако существует возможность объединять результаты нескольких запросов, т.е.
нескольких SELECT, иными словами, несколько множеств объединять в один итоговый набор данных.
Это возможно благодаря инструкции UNION.***

-- Пример с UNION
```
SELECT product_id, product_name, price
FROM goods
WHERE product_id = 1
 
UNION
 
SELECT product_id, product_name, price
FROM goods
WHERE product_id = 3
```

***В процессе такого объединения сами данные никак не модифицируются. Но обязательно следует отметить,
что UNION возвращает только уникальные объединения строк, т.е. если во втором запросе будет абсолютно такая же строка,
как и в первом, в результирующий набор попадет только одна строка, а не две.***

### UNION ALL

***Однако бывают случаи, на самом деле достаточно часто, что необходимо включить в результирующий набор все строки,
как из первого запроса, так и из второго. Для этого в SQL сервере предусмотрено объединение UNION ALL, т.е.
дополнительное указание ключевого слова ALL. Оно будет говорить SQL серверу, что в результирующий набор данных нужно
включить абсолютно все строки.***

```
-- Сравнение. UNION
SELECT product_id, product_name, price
FROM goods
WHERE product_id = 1
 
UNION ALL
 
SELECT product_id, product_name, price
FROM goods
WHERE product_id = 1
```

Ещё обязательно стоит отметить несколько важных правил и условий, без знания которых у Вас не получится использовать эти объединения на практике. Эти правила заключаются в следующем:

* Количество и порядок столбцов во всех запросах должен быть строго одинаковый;
* Тип данных столбцов во всех запросах должен быть совместимым;
* Секцию ORDER BY необходимо указывать после всех запросов, которые объединяются с помощью UNION или UNION ALL.
