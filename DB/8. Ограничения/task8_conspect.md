## Что такое ограничения?

>Ограничения – это объекты базы данных, которые задают правила допустимости определенных значений в столбцах.  
>Иными словами, они формируют некое условие на те данные, которые можно ввести в таблицу и хранить в ней.

Таким образом, ограничения нужны для обеспечения целостности данных в базе данных.

>Целостность данных – это соответствие всей информации в базе данных её внутренней логике,  
>структуре и всем явно заданным правилам. Кроме этого, целостность данных – это когда одна информация в базе  
>данных не противоречит другой информации.

Например, чтобы продать товар, этот товар должен в принципе существовать, возраст или вес не может быть отрицательным, и так далее.

При планировании структуры таблицы следует также продумать и допустимые значения, которые могут храниться в столбце,  
это не менее важно, чем планирование типа данных столбцов.

Ограничения обеспечивают автоматический механизм проверки данных при их внесении, это очень удобно и крайне важно.  
Поэтому рекомендовано подружиться с ограничениями и использовать их на практике.

## Ограничение NOT NULL

В SQL существует несколько типов ограничений, с одним, кстати, Вы уже познакомились. Помните, когда мы создавали таблицы,  
для столбцов мы указывали возможность принятия этим столбцом значения NULL, т.е. является ли он обязательным или нет  
– конструкция NOT NULL и является разновидностью ограничения.

Как задается ограничение NOT NULL, Вы уже знаете, мы это делали на уроке, посвящённом созданию и изменению таблиц.  
Если коротко, то просто при создании таблицы или изменении столбца нужно указать, может ли принимать столбец значения  
NULL или не может (NOT NULL).  

## Ограничение PRIMARY KEY
Следующий тип ограничения, наверное, самый распространённый и важный – это PRIMARY KEY.

>PRIMARY KEY – это ограничение первичного ключа. Первичный ключ представляет собой столбец, значения которого  
>гарантируют уникальность строк. PRIMARY KEY дает нам возможность идентифицировать каждую строку в таблице.  
>Первичный ключ требуется практически для каждой таблицы, и он должен быть у нее один.

Обычно первичный ключ, т.е. ограничение PRIMARY KEY, создают для столбца, который выполняет роль счетчика,  
помните IDETNITY, AUTO_INCREMENT и он не может содержать значения NULL. Кстати, при создании столбца с автоинкрементом  
в MySQL мы сразу создавали первичный ключ, поэтому в инструкции и указывали PRIMARY KEY.

Создав ограничение PRIMARY KEY, Вы можете не беспокоиться о том, что в Вашей таблице товаров вдруг окажется два товара  
с одинаковым идентификатором, иными словами, два одинаковых товара.

Ограничение PRIMARY KEY может содержать набор столбцов, которые имеют значения, уникально идентифицирующие строку в таблице,  
другими словами, первичный ключ может быть составной, состоящих из нескольких столбцов.

Ограничение PRIMARY KEY можно создать как при создании таблицы, так и после, путем ее изменения, т.е. добавления к ней  
ограничения.

При создании таблицы такие ограничения можно объявить двумя способами, на уровне столбца, и на уровне таблицы.  
На уровне столбца обычно добавляют ограничения, которые состоят из одного столбца.

Для примера давайте рассмотрим оба способа создания ограничения PRIMARY KEY, как на уровне столбца, так и на уровне таблицы.  
Для этого создадим две таблицы.

**-- Создание ограничения PRIMARY KEY на уровне столбца**  
```
CREATE TABLE test_table
(
category_id INT NOT NULL PRIMARY KEY,
category_name VARCHAR(100) NOT NULL
);
```

**-- Создание ограничения PRIMARY KEY на уровне таблицы**  
```
CREATE TABLE test_table2
(
category_id INT NOT NULL,
category_name VARCHAR(100) NOT NULL,
PRIMARY KEY (category_id)
);
```

Как видите, мы создаем две тестовые таблицы, и в этих таблицах определено ограничение первичного ключа.

В первом случае ограничение мы добавляем после всех характеристик столбца, т.е. просто пишем PRIMARY KEY.

Во втором случае мы после перечисления всех столбцов как будто добавляем еще один столбец, но не столбец,  
а ограничение. Для этого точно также пишем PRIMARY KEY, только дополнительно в скобочках указываем столбец,  
который будет выполнять роль первичного ключа.

Кроме этого, есть и более расширенный синтаксис объявления ограничений, который позволяет задать название ограничения,  
что очень удобно, так как мы можем указать свое собственное имя ограничения. Дело в том, что если не указывать  
название ограничения, сервер присвоит ему автоматически сгенерированное имя на основе какого-то своего алгоритма.

Чтобы задать имя ограничению, необходимо написать ключевого слово CONSTRAINT, затем его название, а потом то,  
что мы уже знаем, т.е. тип ограничения PRIMARY KEY и столбец, который будет выполнять роль первичного ключа.

Таким образом, если бы мы захотели присвоить имя нашему ограничению, то инструкция выше выглядела бы следующим образом.  

**-- Создание ограничения PRIMARY KEY на уровне таблицы и указание имени ограничения**  
```
CREATE TABLE test_table3
(
category_id INT NOT NULL,
category_name VARCHAR(100) NOT NULL,
CONSTRAINT pk_test_table3 PRIMARY KEY (category_id)
);
```

Присвоение имени ограничения полезно в тех случаях, когда требуется вести учет своих ограничений, например,  
для документации, да и просто во всех сообщениях об ошибках, которые будут связаны с данным ограничением, будет  
фигурировать это название, а если Вы его не знаете, то Вам придётся сначала понять, какое именно ограничение сработало.

Данный синтаксис создания ограничений, как и в предыдущем примере, поддерживают все СУБД.  

Хоть мы и не указывали, но у нас автоматически создался индекс для столбца, который мы указали в качестве первичного  
ключа, т.е. когда мы создаем ограничение PRIMARY KEY, сервер сам, автоматически создает индекс.

Если таблица была уже создана без первичного ключа, именно так мы и делали, когда создавали наши первые тестовые таблицы,  
не считая инструкцию для MySQL, в которой мы все-таки создавали ограничение PRIMARY KEY,  
то добавить ограничение можно и после создания таблицы. Это делается с помощью инструкции ALTER TABLE.

Выполните инструкции, которые представлены чуть ниже, так как в следующих примерах нам потребуется  
первичный ключ у этих таблиц.

Однако если Вы используете MySQL и выполняли инструкцию создания таблиц для MySQL, то Вам не нужно выполнять эти инструкции,  
так как первичный ключ у Вас уже есть.

Если бы мы не создавали идентификацию и не указывали параметры AUTO_INCREMENT и PRIMARY KEY для MySQL,  
то инструкция добавления ограничения первичного ключа выглядела бы точно также.

`ALTER TABLE goods ADD CONSTRAINT pk_goods PRIMARY KEY (product_id);`

`ALTER TABLE categories ADD CONSTRAINT pk_categories PRIMARY KEY (category_id);`  

Вы видите, мы написали инструкцию ALTER TABLE, указали таблицу, в которую хотим внести изменения,  
затем написали команду ADD CONSTRAINT (добавление ограничения), указали имя ограничения, тип,  
и в скобочках перечислили столбцы, которые будут выполнять роль ключевого столбца, т.е. первичного ключа,  
в нашем случае это product_id и category_id.  

## Ограничение FOREIGN KEY
Следующее ограничение FOREIGN KEY – это ограничение внешнего ключа. Данное ограничение задает столбец,  
по которому устанавливается связь с данными в другой таблице. Помните, в наших тестовых таблицах есть общие столбцы,  
например, идентификатор категории? Так вот, чтобы обеспечить полноценную связь и целостность данных,  
мы должны были добавить соответствующее ограничение FOREIGN KEY. Например, если сейчас мы попытаемся добавить  
в таблицу Goods новый товар с категорией, которой нет в списке категорий, т.е. в таблице Categories, ничего не произойдет.  
Но как Вы понимаете, это грубейшая ошибка, а самостоятельно контролировать процесс добавления и проверки данных –  
довольно трудоёмкий процесс. Поэтому у нас есть функционал, который позволяет автоматизировать процесс контроля за данными,  
а именно, мы можем создать ограничение FOREIGN KEY, и тогда добавить такие некорректные данные будет просто невозможно.

Ограничение FOREIGN KEY также можно определить как во время создания таблицы, так и после.  

Сначала давайте рассмотрим пример определения ограничения FOREIGN KEY во время создания таблицы.  

Для этого давайте снова создадим две тестовые таблицы со структурой, похожей на таблицы Goods и Categories.  

Первой создаем таблицу с категориями, которая должна иметь первичный ключ.  

```
CREATE TABLE categories_tmp
(
category_id INT NOT NULL PRIMARY KEY,
category_name VARCHAR(100) NOT NULL
);
```
Второй – таблицу с товарами, которая кроме первичного ключа будет иметь еще и ограничение внешнего ключа.  
Другими словами, мы говорим, что значения определённого столбца, которые будут добавляться в эту таблицу,  
обязательно должны уже существовать в другой таблице, в нашем случае в таблице с категориями.

```
CREATE TABLE goods_tmp
(
product_id INT NOT NULL PRIMARY KEY,
category INT NOT NULL,
product_name VARCHAR(100) NOT NULL,
price NUMERIC(18,2) NULL,
CONSTRAINT fk_category_goods_tmp FOREIGN KEY (category) REFERENCES categories_tmp (category_id)
ON DELETE CASCADE
ON UPDATE NO ACTION
);
```

В данном примере мы после определения столбцов таблицы через запятую написали ключевое слово CONSTRAINT,  
говоря этим, что мы хотим добавить ограничение, затем мы написали имя ограничения, потом тип, т.е. FOREIGN KEY,  
далее в скобочках указали столбец, который будет связан с другой таблицей и подлежит проверке.  
После этого мы указали ключевое слово REFERENCES, название таблицы и столбца, с которым необходимо связать столбец  
из текущей таблицы, т.е. Categories_Tmp.

Инструкция ON DELETE CASCADE говорит о том, что если будет удалена запись из связанной (родительской) таблицы,  
т.е. Categories, то все записи по этому ключу будут удалены и в таблице Goods. Другими словами, если мы удалим категорию,  
то все товары в этой категории также удалятся. Но существуют и другие действия в таких случаях, например,  
не удалять, а присвоить значения NULL или значение по умолчанию.

Инструкция ON UPDATE задает правила обновления родительской таблицы, т.е. также, если ключ будет обновлен,  
то необходимо выполнить определённые действия с записями в дочерней таблице.

Для инструкций ON DELETE и ON UPDATE доступны следующие значения:

* **NO ACTION** – ничего не делать, просто выводить ошибку;
* **CASCADE** – каскадное изменение;
* **SET NULL** – присвоить значение NULL;
* **SET DEFAULT** – присвоить значение по умолчанию  
(однако SET DEFAULT поддерживают не все СУБД,точно работает в PostgreSQL и Microsoft SQL Server).  

Эти инструкции необязательные, их можно и не указывать, тогда при изменении ключа, и в случае наличия связанных записей,  
будет выходить ошибка.

Таким образом, мы имеем две связанные таблицы, и, если Вы попытаетесь добавить прямо сейчас данные в таблицу Goods_Tmp,  
т.е. товар, при этом, как Вы понимаете, у нас нет ни одной категории, возникнет ошибка. Иными словами,  
нам нужно сначала добавить категории в таблицу с категориями.

```
INSERT INTO goods_tmp(product_id, category, product_name, price)
VALUES (1, 1, 'Системный блок', 50);
```

В случае если у Вас уже есть таблицы, но не определено ограничение FOREIGN KEY,  
то Вы его можете добавить инструкцией ALTER TABLE.

Сначала давайте удалим наши тестовые таблицы.

`DROP TABLE goods_tmp, categories_tmp;`  

А теперь давайте добавим ограничение FOREIGN KEY к нашей основной таблице goods.

```
ALTER TABLE goods ADD CONSTRAINT fk_goods_category FOREIGN KEY (category)
REFERENCES categories (category_id);
```

Для этого мы делаем практически все то же самое, что мы делали ранее при создании таблицы, только в инструкции ALTER TABLE.  
А именно, мы указываем команду ADD CONSTRAINT, название ограничения, тип и столбец, затем пишем REFERENCES и указываем  
таблицу и столбец, на который ссылаться. В данном случае мы не указывали инструкции ON DELETE и ON UPDATE,  
т.е. в случае удаления или изменения ключевого столбца будет появляться ошибка.

С помощью именно этого ограничения выстраивается связь между таблицами, оно, наверное, самое сложное,  
поэтому если Вам непонятно, как оно работает, обязательно пересмотрите и перечитайте материалы данного урока заново.  

## Ограничение UNIQUE
Идем далее, на очереди у нас ограничение UNIQUE – это ограничение, которое обеспечивает уникальность значений в столбце  
или нескольких столбцах. С помощью данного ограничения Вы можете исключить повторяющиеся значения в столбце.  
В случае если таблица уже создана, то при добавлении этого ограничения в столбце не должно быть повторяющихся значений.

Ограничение UNIQUE создается синтаксически так же, как и перечисленные выше. Давайте создадим еще одну таблицу,  
в которой будет три столбца. Для первого мы создадим ограничение на уровне столбца, для второго на уровне таблицы,  
для третьего мы создадим ограничение уникальности отдельной инструкцией ALTER TABLE.

```
CREATE TABLE test_table(
column1 INT NOT NULL UNIQUE,
column2 INT NOT NULL,
column3 INT NOT NULL,
CONSTRAINT uq_column2 UNIQUE (column2)
);

ALTER TABLE test_table ADD CONSTRAINT uq_column3 UNIQUE (column3);
```

Как видите, все то же самое, мы пишем ключевое слово CONSTRAINT, имя ограничения и тип, т.е. UNIQUE.  
В итоге мы имеем таблицу, в которой мы создали три ограничения уникальности.  

## Ограничение CHECK

>CHECK – это проверочное ограничение, которое обеспечивает проверку выполнения определенных условий  
>при добавлении значений в столбец.  

Иными словами, если Вам требуется, чтобы в столбце хранились только определённые значения, например,  
по бизнес требованию категорически нельзя хранить товары с ценой 666, контролировать процесс добавления и изменения цены  
самостоятельно очень сложно, поэтому мы должны автоматизировать этот процесс, и лучше всего это сделать с помощью  
проверочного ограничения, которое просто не даст сохранить такое значение в указанный столбец. Ограничение CHECK  
проверяет не существование данных, как FOREIGN KEY, не уникальность данных как UNIQUE, а их корректность с точки  
зрения заданных правил.

Создать проверочное ограничение CHECK можно с любым логическим выражением, которое возвращает значение TRUE или FALSE,  
например, в нашем случае с ценой выражение будет таким: Price не равен 666, т.е. цена не должна равняться 666.  
При этом к одному столбцу мы можем применять несколько проверочных ограничений, например, к тому же столбцу  
с ценой мы можем создать еще одно логическое проверочное ограничение.

Ограничение CHECK можно создать на уровне таблицы и с помощью инструкции ALTER TABLE уже после создания таблицы.  
Давайте создадим таблицу с двумя столбцами, для первого мы определим проверочное ограничение в инструкции создания  
самой таблицы, а для второго уже после ее создания отдельной инструкцией.

```
CREATE TABLE test_table(
column1 INT NOT NULL,
column2 INT NOT NULL,
CONSTRAINT ck_column1 CHECK (column1 <> 0)
);

ALTER TABLE test_table ADD CONSTRAINT ck_column2 CHECK (column2 > column1);
```

Таким образом, мы создали два ограничения.

В первом случае наше проверочное ограничение говорит, что в Column1 не должно быть значений, равных нулю,  
а ограничение для второго столбца говорит, что все значения, которые будут добавляться в Column2, должны быть больше,  
чем в Column1. Иными словами, если мы захотим добавить запись со значениями, например, для Column1 = 5,  
а для Column2 = 3, возникнет ошибка.  

## Ограничение DEFAULT

Есть еще одна разновидность ограничения в SQL, хотя ограничением я бы не назвал эту возможность,  
скорей механизм корректного хранения и ввода данных. Это DEFAULT – значение по умолчанию. Например, в нашей тестовой   
таблице разрешено значение NULL для столбца с ценой, но строки с NULL – это не хорошо, поэтому мы можем добавить  
для данного столбца значение по умолчанию, допустим 0. Иными словами, всякий раз, когда будут добавлены записи с  
неопределенным значением в столбце Price в таблицу, вместо NULL автоматически будут вставлены значения 0.  
Если рассматривать DEFAULT как механизм избавления от значений NULL, то, да, наверное, это ограничение.

Для того чтобы посмотреть, как создается ограничение DEFAULT, т.е. значение по умолчанию,  
давайте создадим еще одну таблицу, в которой у столбца определим значение по умолчанию.

Для этого нам необходимо просто после параметров столбца написать ключевое слово DEFAULT и указать само значение,  
которое и будет выступать в качестве значения по умолчанию.

```
CREATE TABLE test_table(
column1 INT NULL DEFAULT (1),
column2 INT NULL
);
```

## Удаление ограничений

Создавать ограничения мы научились, но иногда требуется эти ограничения удалить, например,  
изменились бизнес правила или что-то в этом роде.

Кстати, в процессе удаления всей таблицы удаляются и все связанные ограничения, и индексы.  
Поэтому удалять отдельно ограничения, если таблица уже удалена, нет необходимости.

Но если таблица остается, и при этом ограничение больше не требуется, мы можем его принудительно удалить.

С удалением ограничений все намного проще, чем с их созданием, для этого мы используем команду DROP CONSTRAINT   
в инструкции ALTER TABLE.

`ALTER TABLE goods DROP CONSTRAINT fk_goods_category;`

В этом примере мы удаляем ограничение внешнего ключа из таблицы Goods.

В MySQL вместо CONSTRAINT необходимо в данном случае указать FOREIGN KEY, так как мы удаляем данный тип ограничения.

`ALTER TABLE goods DROP FOREIGN KEY fk_goods_category;`

