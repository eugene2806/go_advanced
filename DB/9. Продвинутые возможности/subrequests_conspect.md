## Вложенные запросы (подзапросы)

>Вложенный SQL запрос – это отдельный запрос, который используется внутри SQL инструкции.  
>Вложенный запрос также называют внутренним SQL запросом или подзапросом, а инструкцию, в которой используется  
>вложенный запрос, называют внешним SQL запросом.

Вложенные SQL запросы могут быть использованы везде, где разрешено использовать SQL выражения,  
это может быть и секция SELECT, и FROM, и WHERE, и даже JOIN.

Использовать вложенные запросы иногда бывает очень удобно, но обязательно стоит отметить и то, что в некоторых случаях  
использование вложенных запросов может снизить производительность, т.е. замедлить работу всей SQL инструкции.  
Тем более, что нередко вложенный SQL запрос можно заменить простым объединением.

Кроме того, вложенные запросы могут быть вложены друг в друга, но тем самым значительно снижается читабельность  
SQL инструкций и ее понятность, а также повышается ее сложность.

Для чего нам могут потребоваться вложенные запросы?

Например, нам нужно во время выполнения запроса получить данные из другой таблицы, может быть,  
всего один столбец или, что бывает достаточно часто, какие-то расчетные данные (например, агрегированные данные).

Допустим, нам нужно получить список категорий с указанием количества товаров, относящихся к данной категории,  
что-то подобное мы уже делали, когда рассматривали группировку данных, но там мы анализировали таблицу с товарами,  
и если у нас есть категория, в которой нет товаров, то в том запросе она, соответственно,  
не отобразится в итоговом наборе данных.

Поэтому давайте проведем анализ на основе таблицы с категориями.

В запросе мы используем вложенный запрос для определения количества товаров,  
т.е. в подзапросе мы обратимся к другой таблице и подсчитаем количество товаров.

```
SELECT c.category_name AS "Название категории",
    (SELECT COUNT(*)
    FROM goods g
    WHERE g.category = c.category_id) AS &quot;Количество товаров&quot;
FROM categories c;
```  
В списке выборки мы указали два столбца, первый category_name из таблицы Categories, а в качестве второго столбца  
мы указали подзапрос, который написали в скобочках и ему задали псевдоним «Количество товаров».

В данном случае в подзапросе для определения количества товаров в той или иной категории мы использовали связь по  
идентификатору категории, таким образом, мы подсчитывали количество товаров только в той категории, которая указана в  
строке основного запроса. Иными словами, мы передали столбец основного запроса внутрь вложенного запроса для объединения.

В данном подзапросе мы использовали агрегатную функцию COUNT для подсчёта количества товаров.

Вложенные SQL запросы имеют несколько важных особенностей, про которые не стоит забывать при конструировании  
SQL инструкций, например, то, что вложенный запрос всегда заключен в скобки, а также то, что если вложенные запросы  
указаны в списке выборки (как в нашем случае) или в операциях сравнения, то они должны возвращать одиночное значение.  
Другими словами, если Вы напишите подзапрос таким образом, чтобы он возвращал два и более столбцов – будет ошибка!

### Производные таблицы

Подзапросы можно использовать не только в списке выборки, но и в других секциях, например, в условиях в качестве  
выражения можно указать подзапрос, а также очень часто Вам потребуется использовать подзапрос как источник данных,  
т.е. в секции FROM или JOIN. В данных случаях в подзапросе можно указывать несколько столбцов, и такие вложенные  
запросы обычно называют Производные таблицы.

Например, Вам нужно иметь в качестве источника данных в секции FROM не всю таблицу,  
а только несколько столбцов, для этого Вы можете указать подзапрос в секции FROM вместо указания таблицы.

```
SELECT product_id, product_name
FROM (SELECT product_id, product_name
    FROM goods
    WHERE category = 1) AS Query;
``` 

После FROM в скобочках мы написали вложенный запрос к таблице Goods, в списке выборки которого указали 2 столбца.  
Следует отметить, что в данном случае необходимо обязательно указывать псевдоним для подзапроса, т.е. для производной таблицы.

Производную таблицу также можно указывать в качестве источника и в объединениях JOIN, например, следующим образом.

```
SELECT q1.product_id, q1.price, q2.category_name
FROM (SELECT product_id, price, category
    FROM goods) AS q1
INNER JOIN (SELECT category_id, category_name
    FROM categories) AS q2 ON q1.category = q2.category_id;
```

Здесь мы с Вами написали запрос, в котором у нас и в секции FROM, и в секции JOIN используется запрос, т.е. производная таблица.

Очень часто вложенные запросы используют и в условии WHERE, при этом здесь стоит понимать,  
с каким именно оператором сравнения используется вложенный запрос, так как это важно.

Например, если использовать вложенный запрос с оператором равно, то он не может возвращать больше одного значения,  
т.е. если он вернет больше одного значения, выйдет ошибка, и SQL запрос не выполнится. Однако если использовать  
вложенный запрос с оператором IN (включая NOT IN) или EXISTS (включая NOT EXISTS), то вложенный запрос уже может  
возвращать список значений.

```
SELECT product_id, product_name
FROM goods g
WHERE category = (SELECT category_id
                  FROM categories
                  WHERE category_name = 'Мобильные устройства');
```

В этом запросе мы выводим все товары из таблицы Goods, у которых идентификатор категории равен значению,  
которое возвращает вложенный запрос, а он возвращает идентификатор категории с указанным нами наименованием,  
таким образом, в нашем случае вложенный запрос возвращает только одно значение.

``` 
SELECT product_id, product_name
FROM goods g
WHERE category IN (SELECT category_id
                   FROM categories);
```

В этом примере мы используем для сравнения оператор IN, поэтому вложенный запрос в таком случае может уже возвращать  
несколько значений, для примера мы просто убрали условие WHERE во вложенном запросе.

Как было уже отмечено, вложенный запрос может быть вложен в другой вложенный SQL запрос,  
тем самым получается множественная вложенность.

```
SELECT product_id, product_name
FROM (SELECT product_id, product_name
FROM Goods
WHERE Category = (SELECT category_id
FROM categories
WHERE category_name = 'Мобильные устройства')
) AS Query;
```