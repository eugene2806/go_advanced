## Обобщенные табличные выражения (CTE)

>Обобщенное табличное выражение (Common Table Expression, сокращенно CTE) – это результирующий набор данных,  
>у которого есть имя, и к которому можно обращаться в запросе.

Другими словами, допустим, у Вас есть SQL запрос (SELECT), который возвращает определённые данные на основе некого алгоритма,  
и Вам нужно к этому результату обратиться, иными словами, использовать его как часть более крупного SQL запроса.  
Как вариант, и, наверное, первое, что может прийти на ум, это использовать вложенный запрос,  
но это очень сильно усложняет понимание кода всего запроса. Однако мы можем использовать CTE.  

```
WITH TestCTE (product_id, product_name, price)
AS
(
    -- Запрос, который возвращает определённые данные
    SELECT product_id, product_name, price
    FROM goods
    WHERE category = 1
)
-- Запрос, в котором мы можем использовать CTE
SELECT * FROM TestCTE;
```

Например, в данном случае, мы написали обобщенное табличное выражение TestCTE. Для этого мы указали ключевое слово WITH,  
затем в скобочках перечислили названия столбцов, которые будут возвращаться при обращении к TestCTE,  
далее мы написали ключевое слово AS и в скобочках определили запрос, к результату которого мы хотим обращаться.

После этого мы можем обращаться к TestCTE как к обычной таблице! Т.е. мы можем производить объединение с ней,  
анализировать ее и так далее.

После определения обобщенного табличного выражения, т.е. сразу за TestCTE, должна идти инструкция SELECT, UPDATE или DELETE.

Перечисление столбцов после названия CTE (в нашем случае после TestCTE) можно и опустить,  
но в этом случае все столбцы в запросе должны возвращаться с определенным уникальным именем,  
в нашем примере у всех столбцов есть имена и они уникальные, поэтому мы смело можем написать и так.  

```
WITH TestCTE
AS
(
    -- Запрос, который возвращает определённые данные
    SELECT product_id, product_name, price
    FROM goods
    WHERE category = 1
)
-- Запрос, в котором мы можем использовать CTE
SELECT * FROM TestCTE;
```

В обобщенном табличном выражении можно использовать несколько именованных запросов, тем самым разделять  
запрос на логические части, например  

```
WITH TestCTE1 AS -- Первый запрос
(
    -- Представьте, что здесь запрос со своей сложной логикой
    SELECT product_id, category, product_name, price
    FROM goods
),
TestCTE2 AS -- Второй запрос
(
    -- Здесь также сложный запрос
    SELECT category_id, category_name
    FROM categories
)
-- Работаем с результирующими наборами данных двух запросов
SELECT t1.product_name, t2.category_name, t1.price
FROM TestCTE1 t1
LEFT JOIN TestCTE2 T2 ON t1.category = t2.category_id
WHERE t1.category = 1
```

В этом случае TestCTE1 – это первый именованный запрос, TestCTE2 – это второй.

Чтобы показать, что после обобщённого табличного выражения можно использовать не только SELECT, но и другие операторы,  
давайте напишем запрос, в котором после CTE используем DELETE, чтобы удалить несколько строк из таблицы goods.

``` 
WITH TestCTE AS
(
   SELECT product_id
   FROM goods
   WHERE category = 2
     AND price > 100
     AND product_description IS NULL
)
DELETE FROM goods
WHERE product_id IN (SELECT product_id FROM TestCTE);
 
-- Проверяем, что получилось
SELECT * FROM goods;
```

### Рекурсивные запросы
Кроме упрощения написания кода обобщённые табличные выражения предназначены еще и для реализации возможности написания  
рекурсивных запросов, т.е. чтобы в запросе можно было обращаться к собственному результирующему набору данных,  
например, для формирования иерархических данных.

Теперь давайте посмотрим, как работает рекурсивный запрос.  

К примеру у нас есть следующие исходные данные.  

``` 
-- Создание таблицы
CREATE TABLE tmp_table (
   user_id INT NOT NULL,
   post VARCHAR(100) NOT NULL,
   manager_id INT NULL
);
 
-- Добавление данных в таблицу
INSERT INTO tmp_table(user_id, post, manager_id)
   VALUES (1, 'Директор', NULL),
          (2, 'Главный бухгалтер', 1),
          (3, 'Бухгалтер', 2),
          (4, 'Начальник отдела продаж', 1),
          (5, 'Старший менеджер по продажам', 4),
          (6, 'Менеджер по продажам', 5),
          (7, 'Начальник отдела информационных технологий', 1),
          (8, 'Старший программист', 7),
          (9, 'Программист', 8),
          (10, 'Системный администратор', 7);
 
SELECT * FROM tmp_table;
```  

Допустим, что нам необходимо вывести иерархический список сотрудников, т.е. мы хотим видеть,  
на каком уровне работает тот или иной сотрудник.

Для реализации нашей задачи мы можем написать рекурсивный запрос.  

``` 
WITH RECURSIVE TestCTE (user_id, post, manager_id, level_user) AS
(  -- Находим якорь рекурсии
   SELECT user_id, post, manager_id, 0 AS level_user
   FROM tmp_table
   WHERE manager_id IS NULL
    
   UNION ALL
 
   -- Делаем объединение с TestCTE (хотя мы его еще не дописали)
   SELECT t1.user_id, t1.post, t1.manager_id, t2.level_user + 1
   FROM tmp_table t1
   JOIN TestCTE t2 ON t1.manager_id = t2.user_id
)
SELECT *
FROM TestCTE
ORDER BY level_user;
```  

В итоге, если мы захотим, мы можем легко получить список сотрудников определенного уровня, например,  
нам нужны только начальники отделов, для этого мы просто в указанный выше запрос добавим условие WHERE level_user = 1  

``` 
WITH RECURSIVE TestCTE (user_id, post, manager_id, level_user) AS
(  -- Находим якорь рекурсии
   SELECT user_id, post, manager_id, 0 AS level_user
   FROM tmp_table
   WHERE manager_id IS NULL
 
   UNION ALL
 
   -- Делаем объединение с TestCTE (хотя мы его еще не дописали)
   SELECT t1.user_id, t1.post, t1.manager_id, t2.level_user + 1
   FROM tmp_table t1
   JOIN TestCTE t2 ON t1.manager_id = t2.user_id
)
SELECT *
FROM TestCTE
WHERE level_user = 1
ORDER BY level_user;
```  

*При написании рекурсивного обобщенного табличного выражения нужно быть внимательным, так как неправильное его  
составление может привести к бесконечному циклу.*
*В заключение еще раз хочется отметить, что обобщенное табличное выражение – это очень удобный и полезный механизм  
для повышения читабельности SQL инструкций.*