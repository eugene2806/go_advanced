## Транзакции

> **Транзакция** – это команда или блок команд (инструкций), которые успешно завершаются как единое целое,   
>при этом в базе данных все внесенные изменения фиксируются на постоянной основе, или отменяются, т.е. все изменения,    
>внесенные любой командой, входящей в транзакцию, будут отменены.  

Другими словами, если одна команда или инструкция внутри транзакции завершилась с ошибкой,  
то все, что было отработано перед ней, также отменяется, даже если предыдущие команды завершились успешно.  

>Транзакции – это отличный механизм обеспечения целостности данных.

У транзакции есть 4 очень важных свойства:  

* **Атомарность** – все команды в транзакции либо полностью выполняются, и соответственно, фиксируются все изменения данных,  
либо ничего не выполняется и ничего не фиксируется;
* **Согласованность** – данные, в случае успешного выполнения транзакции, должны соблюдать все установленные правила  
в части различных ограничений, первичных и внешних ключей, определенных в базе данных;
* **Изоляция** – механизм предоставления доступа к данным. Транзакция изолирует данные, с которыми она работает,  
для того чтобы другие транзакции получали только согласованные данные;
* **Надежность** – все внесенные изменения фиксируются и данные считаются надежными, если транзакция была успешно завершена.  
Это также означает, что изменения должны быть записаны так, чтобы данные не были потеряны в случае сбоя системы.  

По сути каждая отдельная инструкция языка SQL является транзакцией, это называется «Автоматическое принятие транзакций»  
или «Неявные транзакции», но также есть и явные транзакции, это когда мы сами явно начинаем транзакцию и также явно  
заканчиваем ее, т.е. делаем все это с помощью специальных команд.

Для того чтобы понять, как работают транзакции, и для чего они нужны, давайте рассмотрим пример.

*Допустим, у Вас есть процедура, которая осуществляет перевод средств с одного счета на другой, соответственно,  
как минимум у Вас будет две операции в этой процедуре, снятие средств и зачисление средств, например,  
две инструкции UPDATE. Но в каждой из этих операций может возникнуть ошибка и инструкция не выполнится.  
А теперь представьте, что первая инструкция снимает деньги, она выполнилась успешно, вторая инструкция зачисляет деньги  
и в ней возникла ошибка, без транзакции снятые деньги просто потеряются, так как они никуда не будут зачислены.  
Чтобы этого не допустить, все SQL инструкции, которые логически что-то объединяет, пишут внутри транзакции и тогда,  
если наступит подобная ситуация, все изменения будут отменены, т.е. деньги вернутся обратно на счет.*  

### Команды управления транзакциями

PostgreSQL

* BEGIN TRANSACTION или BEGIN – начало новой транзакции;
* COMMIT TRANSACTION или COMMIT – фиксирует текущую транзакцию, сохраняя все изменения на постоянной основе;
* ROLLBACK TRANSACTION или ROLLBACK – откатывает текущую транзакцию, отменяя все изменения;
* SAVEPOINT – команда устанавливает новую точку сохранения в текущей транзакции.  

```
BEGIN;

-- Инструкция 1
UPDATE goods SET price = 70
WHERE product_id = 1;

-- Инструкция 2
UPDATE goods SET price = 40
WHERE product_id = 2;

COMMIT;

SELECT product_id, product_name, price
FROM Goods;
```

В этом примере у нас всего две инструкции, которые изменяют данные, но допустим, что они взаимосвязаны,  
т.е. они обе обязательно должны выполниться вместе или не выполниться также вместе.

Поэтому мы решили эти инструкции объединить в одну транзакцию.

Сначала мы открываем транзакцию командой BEGIN, далее пишем все необходимые инструкции, которые мы хотим объединить  
в транзакцию.

После этого командой COMMIT мы сохраняем все внесенные изменения.

В данном случае у нас нет никаких ошибок, все инструкции выполнились успешно. Как результат, транзакция завершена  
также успешно и все изменения сохранены на постоянной основе командой COMMIT.

Однако, если в любой из инструкций возникнет ошибка, транзакция не завершится, и все изменения не сохранятся.

Например, если во второй инструкции мы попытаемся записать в столбец Price какое-нибудь текстовое значение,  
то у нас возникнет ошибка, и изменения, внесённые первой инструкцией, не зафиксируются на постоянной основе   
(в MySQL для отмены всех изменений необходимо отслеживать ошибку и принудительно запускать команду ROLLBACK).

```
BEGIN;

-- Инструкция 1
UPDATE goods SET price = 80
WHERE product_id = 1;

-- Инструкция 2
UPDATE goods SET price = 'Текст'
WHERE product_id = 2;

ROLLBACK;

SELECT product_id, product_name, price
FROM Goods;
```

Во время выполнения транзакции все данные, над которыми производятся изменения, блокируются до завершения транзакции,  
так как, когда один процесс изменяет данные, другой процесс не может одновременно изменять их. В СУБД существует механизм,  
который блокирует (изолирует) данные во время выполнения транзакции. У данного механизма есть несколько уровней изоляции,  
каждый из которых определяет степень блокировки данных.  

### Уровни изоляции

Давайте рассмотрим уровни изоляции.

* **READ UNCOMMITTED** – самый низкий уровень, при котором SQL сервер разрешает так называемое «грязное чтение».  
Грязным чтением называют считывание неподтвержденных данных, иными словами, если транзакция, которая изменяет данные,  
не завершена, другая транзакция может получить уже измененные данные, хотя они еще не зафиксированы и могут отмениться.

* **READ COMMITTED** – этот уровень уже запрещает грязное чтение, в данном случае все процессы, запросившие данные,  
которые изменяются в тот же момент в другой транзакции, будут ждать завершения этой транзакции и подтверждения фиксации данных.

* **REPEATABLE READ** – на данном уровне изоляции запрещается изменение данных между двумя операциями чтения в одной транзакции.  
Здесь происходит запрет на так называемое «неповторяющееся чтение» или «несогласованный анализ».  
Другими словами, если в одной транзакции есть несколько операций чтения, данные будут блокированы и их нельзя будет изменить  
в другой транзакции. Таким образом, Вы избежите ситуации, когда в начале транзакции Вы запросили данные,  
провели их анализ (некое вычисление), в конце транзакции запросили те же самые данные, а они уже отличаются от  
первоначальных, так как они были изменены другой транзакцией.

Также уровень REPEATABLE READ, как и остальные, запрещает «Потерянное обновление» – это когда две транзакции  
сначала считывают одни и те же данные, а затем изменяют их на основе неких вычислений, в результате обе транзакции  
выполнятся, но данные будут те, которые зафиксировала последняя операция обновления. Это происходит потому,  
что данные в операциях чтения в начале этих транзакций не были заблокированы.

* **SERIALIZABLE** – данный уровень исключает чтение «фантомных» записей. Фантомные записи – это те записи, которые появились  
между началом и завершением транзакции. Иными словами, в начале транзакции Вы запросили определенные данные,  
в конце транзакции Вы запрашиваете их снова с тем же фильтром, но там уже есть и новые данные, которые добавлены  
другой транзакцией. Более низкие уровни изоляции не блокировали строки, которых еще нет в таблице, данный уровень  
блокирует все строки, соответствующие фильтру запроса, с которыми будет работать транзакция, как существующие,  
так и те, что могут быть добавлены.  

### Побочные эффекты параллелизма

На основе вышеизложенного мы можем выделить несколько побочных эффектов, которые могут возникнуть в результате  
параллельного использования данных:

* **Потерянное обновление (Lost Update)** – при одновременном изменении данных разными транзакциями одно из изменений будет потеряно;
* **Грязное чтение (Dirty Read)** – чтение неподтвержденных данных;
* **Неповторяющееся чтение (Non-Repeatable Read)** – чтение измененных данных в рамках одной транзакции;
* **Фантомное чтение (Phantom Reads)** – чтение записей, которые появились между началом и завершением транзакции.  

Каждый из уровней изоляции устраняет определенные побочные эффекты. В таблице ниже приведены сводные данные.  

| Уровень изоляции   | Потерянное обновление | Грязное чтение | Неповторяющееся чтение | Фантомные записи |
|--------------------|-----------------------|----------------|------------------------|------------------|
| **READ UNCOMMITTED** | Устраняет             | Не устраняет   | Не устраняет           | Не устраняет     |
| **READ COMMITTED**   | Устраняет             | Устраняет      | Не устраняет           | Не устраняет     |
| **REPEATABLE READ**  | Устраняет             | Устраняет      | Устраняет              | Не устраняет     |
| **SERIALIZABLE**     | Устраняет             | Устраняет      | Устраняет              | Устраняет        |  

### ключение уровня изоляции
Для того чтобы включить тот или иной уровень изоляции для сессии, необходимо выполнить команду  
SET TRANSACTION ISOLATION LEVEL и указать название уровня изоляции.

`SET TRANSACTION ISOLATION LEVEL READ COMMITTED;`
