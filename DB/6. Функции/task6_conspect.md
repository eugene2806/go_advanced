## Строковые функции

### LTRIM, RTRIM и TRIM
Нередко случается, что в текстовом столбце в таблице в начале или в конце строки, пользователи могут занести пробелы,  
а они также являются символами, и при обработке подобных значений могут возникнуть некоторые проблемы.  
Поэтому в SQL есть специальные функции, которые в запросе могут возвращать данные без этих пробелов,  
т.е. убрать все пробелы в начале или в конце.

Функция LTRIM убирает все пробелы в начале строки, функция RTRIM в конце, а функция TRIM и в начале и в конце.

Во многие системные функции необходимо передавать параметры.  
В функции LTRIM, RTRIM и TRIM нужно передать саму текстовую строку, из которой нужно удалить пробелы,  
это может быть как просто текст, так и столбец, т.е. название столбца в таблице.

Для примера давайте напишем запрос, в котором мы обратимся к таблице Goods,  
и получим все значения столбца product_name без пробелов в начале и в конце строки,  
которые есть в этом столбце, такие данные мы специально туда добавили.

Для наглядности столбец product_name мы выведем несколько раз, чтобы видеть,  
как изменяется результирующий набор данных. Также здесь показано, что функции можно сочетать,  
т.е. вкладывать друг в друга, например, в данном запросе мы к столбцу product_name сначала применили функцию LTRIM,  
а затем RTRIM (колонка [RTRIM и LTRIM]), таким образом, мы сразу удалили пробелы как в начале, так и в конце.  
Однако эти действия эквивалентны действиям, которые выполняет функция TRIM, т.е. она делает то же самое, иными словами,  
использование двух функций RTRIM и LTRIM для удаления всех пробелов как в начале, так и в конце, не требуется.

```
SELECT product_name AS "Исходное значение",
LTRIM(product_name) AS "LTRIM",
RTRIM(product_name) AS "RTRIM",
RTRIM(LTRIM(product_name)) AS "RTRIM и LTRIM",
TRIM(product_name) AS "TRIM"
FROM goods;
```

### LOWER и UPPER
Следующие функции, которые стоит рассмотреть, – это LOWER и UPPER, так как бывают случаи,  
что нужно значение всей строки получить в определённом регистре, в верхнем или в нижнем.  
Эти функции в языке SQL используются именно для этих целей.

* UPPER – возвращает все символы указанной строки в верхнем регистре;
* LOWER – возвращает все символы указанной строки в нижнем регистре.  
  *В данном примере наглядно видно, как работают данные функции.*

```
SELECT product_name AS "Исходное значение",
LOWER (product_name) AS "LOWER",
UPPER(product_name) AS "UPPER"
FROM goods;
```

### LEFT и RIGHT
Если Вам нужно получить не всю строку, а только первые несколько символов или последние несколько символов,  
можно использовать функции LEFT и RIGHT.

LEFT возвращает символы слева, RIGHT соответственно справа.

Эти функции принимают уже два параметра, первый – это строка, а второй – количество символов, которые нужно получить.

```
SELECT product_name AS "Исходное значение",
LEFT(product_name, 3) AS "LEFT",
RIGHT(product_name, 3) AS "RIGHT",
LEFT(LTRIM(product_name), 3) AS "LEFT и LTRIM",
RIGHT(RTRIM(product_name), 3) AS "RIGHT и RTRIM"
FROM goods;
```

### SUBSTRING
Далее, давайте рассмотрим функцию SUBSTRING, с помощью которой можно вывести определенную часть строки, например,  
начиная с указанной позиции, и определенное количество символов. В данную функцию необходимо передать три параметра,  
первый – строка, второй – начальная позиция, третий – количество символов.

В данном случае мы выводим часть строки, а именно всего 5 символов, начиная с 3 символа.

```
SELECT product_name AS "Исходное значение",
SUBSTRING(product_name, 3, 5) AS "SUBSTRING"
FROM goods;
```

### CONCAT
Иногда требуется объединить несколько текстовых значений в одну строку, т.е. выполнить конкатенацию строк.

Для этих целей в языке SQL реализована функция CONCAT, которая объединяет все параметры,  
в которых передаются текстовые значения, в одну строку. Параметров можно передавать несколько,  
а в качестве них можно указывать как константную строку, т.е. просто текст, так и столбец таблицы.

```
SELECT product_name AS "Исходное значение",
CONCAT('Наименование товара – ', product_name) AS "CONCAT",
CONCAT('Иванов', ' ', 'Иван', ' ', 'Иванович') AS "ФИО"
FROM goods;
```

### REPLACE
Если Вам потребуется заменить часть строки на какое-то другое значение, то для этого в SQL реализована функция REPLACE.

Первым параметром указывается исходный текст, вторым – что мы ищем и хотим заменить,  
а третьим – на что мы будем заменять найденную подстроку, указанную во втором параметре.

```
SELECT product_name AS "Исходное значение",
REPLACE (product_name, 'блок', 'стол') AS "REPLACE"
FROM goods;
```

В этом примере мы в столбце product_name ищем слово «блок» и если его находим, то заменяем на «стол».

Здесь обязательно стоит учитывать, что эта функция ищет и заменяет все вхождения указанного текстового значения,  
т.е. если сочетание букв «блок» встретится как часть какого-то другого слова, то это сочетание букв также будет заменено.


`SELECT REPLACE ('блокнот', 'блок', 'стол') AS "REPLACE";`

### REVERSE
Также в SQL есть функция, которая позволяет вывести строку, где все символы переставлены в обратном порядке справа налево.  
Иногда тоже бывает очень полезно

```
SELECT product_name AS "Исходное значение",
REVERSE (product_name) AS "REVERSE"
FROM goods;
```

### LENGTH Длина строки
Функций для работы со строками на самом деле больше, однако в каждой СУБД их набор и названия отличаются, например,  
даже операция подсчета количества символов, которая достаточно часто требуется в работе,  
во всех СУБД реализуется по-своему, а точнее название функций везде разное.

* В Microsoft SQL Server – используется функция LEN
* В MySQL – CHAR_LENGTH
* В PostgreSQL – LENGTH и CHAR_LENGTH  
  Хотя принцип их работы одинаковый, т.е. они подсчитывают количество символов в строке.

Пример для PostgreSQL

```
SELECT product_name AS "Исходное значение",
LENGTH (product_name) AS "LENGTH",
LENGTH (LTRIM(product_name)) AS "LTRIM и LENGTH"
FROM goods;
```

## Математические функции

В языке SQL, конечно же, есть функции, которые позволяют производить различные математические расчеты,  
как простые, так и сложные. Вот некоторые математические функции:

`ABS` – функция возвращает абсолютное (положительное) значение указанного числа;  
`ROUND` – функция возвращает числовое значение, округленное до указанной во входящем параметре точности;  
`CEILING` – функция возвращает наименьшее целое число, которое больше или равно числовому выражению,
указанному во входящем параметре (если по-простому, то округление до целого в большую сторону);  
`FLOOR` – функция возвращает наибольшее целое число, меньшее или равное указанному числовому выражению
(т.е. округление до целого в меньшую сторону);  
`SQRT` – функция возвращает квадратный корень указанного числа;  
`POWER` – функция возвращает возведенное в заданную в параметре степень указанное число;  
`PI` – возвращает константное значение PI;  
`SIGN` – возвращает положительное (1), нулевое (0) или отрицательное (-1) значение, обозначающее знак заданного выражения.  
Кроме этого есть и тригонометрические функции, которые могут возвращать тангенс, котангенс, косинус и так далее.

`TAN` – тангенс;  
`COT` – котангенс;  
`COS` – косинус;  
`SIN` – синус;  
`ACOS` – арккосинус;  
`ASIN` – арксинус;  
`ATAN` – арктангенс.  
Пример использования математических функций

```
SELECT ABS(-100) AS "ABS",
ROUND(1.567, 2) AS "ROUND",
CEILING(1.6) AS "CEILING",
FLOOR(1.6) AS "FLOOR",
SQRT(16) AS "SQRT",
POWER(4, 2) AS "POWER",
PI() AS "PI",
SIGN(25) AS "SIGN"
```

## Другие полезные функции и выражения

### Функция CAST
Принцип работы функции CAST следующий.

В качестве параметра ей необходимо передать выражение, которое Вы хотите преобразовать,  
затем указать ключевое слово AS и после него написать название того типа данных,  
в который Вы хотите преобразовать указанное выражение. И если это возможно, функция вернет Вам соответствующий результат.

В этом примере мы преобразовываем текстовую строку, в которой указана дата, в тип данных DATE.

`SELECT CAST('2020.05.01' AS DATE) AS "CAST";`

### Выражение COALESCE

На текущий момент Вы уже знаете, что в SQL существуют так называемые значения NULL, т.е. неопределенные значения  
– это когда значения как такового нет.

И NULL – это плохо, но в то же время с таким значением Вы будете встречаться достаточно часто,  
поэтому Вам необходимо уметь работать с этим значением.

В языке SQL для этого есть специальные инструменты, в частности выражение COALESCE,  
которое умеет проверять входящие параметры на значение NULL.

>COALESCE – это выражение, можно сказать функция, которая возвращает первое выражение из списка параметров, которое не равняется NULL.

*Иными словами, Вы можете указать сколько угодно параметров, и COALESCE вернет первый, отличный от NULL.*

```
SELECT product_description AS product_description,
COALESCE(product_description, 'Без описания') AS "COALESCE"
FROM goods;
```

*В этом примере мы выводим столбец product_description, при этом проверяем, если какие-то записи не заполнены,  
т.е. в них значение NULL, то вместо этого значения выводим константное выражение «Без описания»  
и делаем это с помощью выражения COALESCE.*

### Выражение NULLIF
Чтобы выполнить некое обратное действие, которое выполняет COALESCE, в SQL есть выражение NULLIF.

>NULLIF – это выражение, которое возвращает значение NULL, если два указанных в параметрах выражения равны,  
>а если выражения неравны, то возвращается первое выражение.

Принцип работы данного NULLIF достаточно прост, мы сравниваем два параметра, если они равняются, значит,  
возвращается значение NULL, а если не равняются, то значение из первого параметра.

Это будет полезно, например, когда мы не хотим учитывать какие-нибудь значения в столбце.

```
SELECT product_id,
product_description AS product_description,
NULLIF(product_description, 'Подлежит ремонту') AS "NULLIF"
FROM goods;
```

*В данном случае мы выводим столбец product_description, при этом мы не хотим, чтобы нам выводились определенные значения,  
у нас это текст «Подлежит ремонту», и нам лучше, чтобы вообще этого значения не было в итоговом наборе данных,  
поэтому для этого мы можем использовать выражение NULLIF.*

*И мы видим, что в результирующем наборе интересующее нас значение было заменено на NULL.*