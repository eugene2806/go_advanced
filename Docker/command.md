# Команды Docker

[Создание контейнера](#создание-контейнера)      
[Запуск контейнера](#запуск-контейнера)  
[Остановка контейнера](#остановка-контейнера)  
[Удаление контейнера](#удаление-контейнера)  
[Временная остановка контейнера (pause)](#временная-остановка-контейнера)  
[Start и Restart контейнера](#start-и-restart-контейнера)  
[Выполнение bash команд внутри контейнера (exec)](#выполнение-bash-команд-внутри-контейнера)  
[Перенос файлов в контейнер и на локальную машину (cp, diff)](#перенос-файлов-в-контейнер-и-на-локальную-машину)  
[Типы монтирования в Docker: bind, volume и tmpfs](#типы-монтирования-в-docker-bind-tmpfs-и-volume)  
[Networking - работа с сетями](#networking---работа-с-сетями)   
[Building images](#building-images)  
[Docker Compose](#docker-compose)





## Создание контейнера

- [x] `docker create alpine:latest` - **Создает image**

- [x] `docker images` - **Показывает все images**

- [x] `docker ps` - **Показывает запущенные контейнеры**

- [x] `docker ps -a` - **Показывает все контейнеры**

- [x] `docker inspect 7b7b86ce581f` - **Показывает информацию о контейнере**
---

## Запуск контейнера

- [x] `docker start 7b7b86ce581f` - **Запускает контейнер**
---

## Остановка контейнера

- [x] `docker stop 7b7b86ce581f` - **Останавливает контейнер**


>*Механизм: При использовании команды docker stop, контейнеру сначала посылается сигнал SIGTERM,  
>который даёт процессу внутри контейнера возможность корректно завершиться. Если процесс не завершится  
>в течение определённого времени (по умолчанию — 10 секунд), Docker отправит сигнал SIGKILL,  
>который принудительно завершит процесс.*
>
>>*Цель: Остановка контейнера мягким способом, предоставляя приложению время на выполнение завершающих операций  
>>(например, завершение активных запросов, сохранение данных и т.д.).*

- [x] `docker kill 7b7b86ce581f` - **Останавливает контейнер сразу**

>*Механизм: Команда docker kill моментально отправляет контейнеру сигнал SIGKILL, что немедленно завершает процесс.  
>В этом случае приложение не получает времени на корректное завершение, оно просто мгновенно останавливается.*  
>>
>>*Цель: Принудительное завершение работы контейнера, если нужно быстро его остановить или если docker stop не сработал.*
---

## Удаление контейнера

- [x] `docker rm (-f) 7b7b86ce581f` - **Удаляет контейнер. -f Остонавливает и удаляет контейнер**
---

## Временная остановка контейнера

- [x] `docker pause 7b7b86ce581f` - **Временно останавливает контейнер для освобождения ресурсов CPU**

- [x] `docker unpause 7b7b86ce581f` - **Запускает остановленный контейнер**

- [x] `docker logs 7b7b86ce581f` - **Показывает логи контейнера**

- [x] `docker stats --no-stream` - **Показывает ресурсы выделяемые под контейнеры**
---

## Start и Restart контейнера

### - Run -
- [x] `docker run -e POSTGRES_PASSWORD=pass postgres` - **Выполняет create + start команды (нет ввода)**

***Основные флаги для docker run***

>1. `-d, --detach:` Запускает контейнер в фоновом режиме (detached mode), возвращая управление терминалу.  
>`docker run -e POSTGRES_PASSWORD=pass -d postgres` - **Выполняет create + start команды (есть ввод команд)**  
>2. `-it:` Объединение двух флагов:  
>-i, --interactive: Поддерживает стандартный ввод (stdin), чтобы контейнер оставался активным для ввода команд.  
>-t, --tty: Создаёт псевдотерминал, что удобно для запуска интерактивных приложений.  
>3. `--env, -e:` Передаёт переменные окружения в контейнер.
>4. `-p, --publish:` Пробрасывает порты из контейнера на хост-машину.  
>Формат: хостовый_порт:порт_контейнера. `docker run -p 8080:80 nginx`

### - Restart -   
- [x] `docker restart (-t, --time) 7b7b86ce581f` - **Перезапускает контейнер. -t, --time время ожидания перед перезапуском**

***Варианты политики перезапуска:***  
`docker run --restart=always my_container`

>1. `no` (по умолчанию): Docker не будет автоматически перезапускать контейнер.  
>2. `always:` Docker всегда будет перезапускать контейнер, если он остановлен, независимо от причины.  
>Контейнер также будет перезапускаться после перезапуска хоста Docker.   
>3. `on-failure[:max-retries]:` Docker перезапустит контейнер только в случае, если он завершился с ошибкой  
>(ненулевой код выхода). Можно указать максимальное количество попыток перезапуска.  
>Пример: **on-failure:5** — перезапустит контейнер до 5 раз, если он завершился с ошибкой.
>4. `unless-stopped:` Контейнер будет перезапущен всегда, кроме случая, когда его явно остановили.  
>После перезапуска хоста Docker контейнер также будет перезапущен.
---

## Выполнение bash команд внутри контейнера

- [x] `docker exec 7b7b86ce581f ls` - **Выполнит команду ls внутри контейнера**
- [x] `docker exec 327 which sh(bash)` - **Проверяет установленные оболочки**

***Основные флаги для docker exec***

>1. `-i, --interactive:` Оставляет стандартный ввод (stdin) открытым, чтобы взаимодействовать с процессом.  
>Это позволяет передавать команды в контейнер в реальном времени.  
>`docker exec -i 327 sh` - **Передает команды в оболочку shell в контейнере**
>2. `-t, --tty:` Создаёт псевдотерминал (tty), что особенно полезно для работы с интерактивными программами  
>(например, запуском shell сессии). Часто используется с флагом -i для интерактивного сеанса.  
>`docker exec -it 327 sh` - **Создаст терминал для работы в контейнере**  
>`docker run -it alpine sh` - **Запустит контейнер сразу вызвав терминал**
---

## Перенос файлов в контейнер и на локальную машину

- [x] `docker cp copy_test 7b7b86ce581f:/` - **Копирование папки из корня на локальной машине в корень контейнера**

- [x] `docker cp 7b7b86ce581f:/copy_test/copy.txt copy.txt  ` - **Копирование файла из папки контейнера в корень на локальной машине**

- [x] `docker diff 7b7b86ce581f` - **Показывает все изменения в контейнере**
---

## Типы монтирования в Docker: bind, tmpfs и volume

### - Bind -

- [x] `docker run -it --mount type=bind,source="$(pwd)"/copy_test,target=/app alpine sh` - **Монтирует каталог или файл с хостовой машины в контейнер**

>Флаг `--mount type=bind` в Docker используется для монтирования каталога или файла с хостовой машины (твоего компьютера)  
>в контейнер. Это позволяет контейнеру работать с файлами и директориями на хосте так, как будто они находятся внутри контейнера.
>
>>1. *type=bind: Указывает, что используется bind-монтирование (прямое связывание директории/файла с хоста в контейнер).*
>>2. *source: Путь к директории или файлу на хосте, который ты хочешь смонтировать.*
>>3. *target: Путь внутри контейнера, куда будет смонтирован источник с хоста.*   

### - Tmpfs -

- [x] `docker run -it --mount type=tmpfs,target=/temp,tmpfs-size=16k,tmpfs-mode=1777 alpine sh` - **Запускает контейнер Docker с временной файловой системой (tmpfs)**  

***Разбор компонентов:***  

>1. `docker run:` *Команда для создания и запуска контейнера.*
>2. `-it:`
>* **-i (interactive):** Оставляет стандартный ввод (stdin) контейнера открытым для взаимодействия.  
>* **-t (tty):** Создаёт терминал (TTY) для интерактивного сеанса.
>
>3. `--mount type=tmpfs:` *Указывает, что будет использоваться временная файловая система (tmpfs).*    
>Это означает, что данные будут храниться в оперативной памяти, и они будут потеряны при остановке контейнера.
>
>4. `target=/temp:` *Указывает, что временная файловая система будет смонтирована в контейнере по пути /temp.*
>* 5tmpfs-size=16k: Устанавливает размер временной файловой системы в 16 килобайт.    
>Это ограничение на объём памяти, который может быть использован для хранения данных в этой файловой системе.
>
>6. `tmpfs-mode=1777:` *Устанавливает права доступа для монтируемой временной файловой системы.*    
>Значение 1777 соответствует правам доступа rwxrwxrwt, что означает:
>
>>* **rwx:** Чтение, запись и выполнение для владельца.
>>* **rwx:** Чтение, запись и выполнение для группы.
>>* **rwx:** Чтение, запись и выполнение для всех остальных.
>>* **t:** Установка бита "sticky", который позволяет только владельцу файла удалять или изменять его.
>
>7. `alpine sh:` *Указывает, что будет использоваться образ Alpine, и запускает в контейнере командную оболочку sh.*  

### - Volume -

- [x] `  docker run -it --mount type=volume,source=postgresql-data,target=/data alpine sh` - **Запускает контейнер Docker с использованием тома (volume) для хранения данных**  

***Разбор компонентов:***   

>1. `docker run -it:` *Создает и запускает новый контейнер в интерактивном режиме с TTY (терминалом).*  
>
>2. `--mount type=volume,source=postgresql-data,target=/data:`
>
>>* **type=volume:** Указывает, что мы используем том (volume) для монтирования.  
>>* **source=postgresql-data:** Имя тома, который будет создан или использован. Если тома с таким именем ещё не существует, Docker создаст его.  
>>* **target=/data:** Путь внутри контейнера, по которому будет смонтирован том. Все данные, записанные в /data внутри контейнера, будут храниться в томе postgresql-data.  

3. `alpine sh:` *Использует образ Alpine и запускает командную оболочку sh внутри контейнера.*

### Команды для удаления volume

- [x] `docker volume rm postgresql-data` - **Удаляет volume postgresql-data**  
- [x] `docker volume rm prune` - **Удаляет неиспользуемые volume**  

>### Зачем использовать тома?
>
>1. **Долговременное хранение:**
>
>- Данные, сохраненные в /data, останутся доступными даже после остановки и удаления контейнера.  
Это идеально подходит для хранения данных баз данных, конфигураций и других важных файлов.  
>
>2. **Изоляция данных:**
>
>- Использование томов позволяет изолировать данные от жизненного цикла контейнера.  
>Ты можешь создавать и удалять контейнеры без потери данных.  
>
>3. **Обмен данными между контейнерами:**
>
>- Если у тебя несколько контейнеров, которые должны работать с одними и теми же данными, они могут использовать один и тот же том.  
>Это упрощает обмен данными между различными сервисами.  
>
>>**Пример использования:**  
>>
>>*Хранение данных PostgreSQL: Если ты собираешься использовать этот контейнер для PostgreSQL,   
>>ты можешь запустить PostgreSQL в контейнере и настроить его так, чтобы он хранил все свои данные в /data.   
>>Все данные будут сохраняться в томе postgresql-data, и ты сможешь использовать его повторно в других контейнерах, если потребуется.*
---

## Networking - работа с сетями

### - Bridge Driver -

- [x] `docker run -it -d (--network alpine-net-1) --name alpine1 alpine sh` - **Запускает контейнер с именем alpine1 в фоновом режиме с командной строкой**  

- [x] `docker attach alpine2` - **Подключается к работающему контейнеру в docker**   

>**Docker Bridge Driver** — это один из типов сетевых драйверов, предоставляемых Docker, который создает внутреннюю сетевую изоляцию для контейнеров.   
>По умолчанию, когда вы запускаете контейнеры без явного указания сети, они подключаются к сети с именем bridge.  
>
>>**Основные характеристики:**  
>>
>>1. **Изолированная сеть:**  
>>Контейнеры, работающие на одной и той же сети bridge, могут общаться друг с другом, используя IP-адреса или имена контейнеров,  
>>но они изолированы от контейнеров в других сетях.  
>>
>>2. **Виртуальный коммутатор:**  
>>bridge действует как виртуальный коммутатор, который позволяет контейнерам обмениваться данными.  
>>
>>3. **Статическая подсеть:**  
>>По умолчанию Docker создает сеть bridge с заданной подсетью (обычно 172.17.0.0/16), но вы можете изменить это, создавая пользовательские сети.  
>>
>>4. **IP-адресация:**  
>>Каждому контейнеру, подключенному к сети bridge, назначается уникальный IP-адрес из диапазона, который определяет сеть.
>>
>>5. **Фаервол:**  
>>Контейнеры в сети bridge могут иметь ограничения на входящий и исходящий трафик, которые можно настроить с помощью правил фаервола на уровне хоста.  
>>
>>6. **Перенаправление портов:**  
>>Вы можете перенаправлять порты хостовой машины на контейнеры, используя флаг -p при запуске контейнера.  
>>Это позволяет вам получать доступ к сервисам, работающим в контейнерах, извне.


### Команды для работы с сетью

1. - [x] `docker network create` - **Создает новую сеть**  
2. - [x] `docker network ls` - **Отображает список всех сетей, созданных в Docker**  
3. - [x] `docker network inspect` - **Показывает подробную информацию о конкретной сети, включая её конфигурацию и контейнеры, подключенные к ней**  
4. - [x] `docker network rm` - **Удаляет указанную сеть. Сеть можно удалить только в том случае, если к ней не подключены контейнеры**  
5. - [x] `docker network connect` - **Подключает контейнер к существующей сети**  
6. - [x] `docker network disconnect` - **Отключает контейнер от сети**  
7. - [x] `docker network prune` - **Удаляет все неиспользуемые сети, чтобы освободить место**  

**Основные параметры:**  

>`--driver:` Указывает драйвер сети, который нужно использовать (например, bridge, overlay, macvlan).  
>`--subnet:` Задаёт подсеть для создаваемой сети.  
>`--gateway:` Задаёт шлюз для сети. 

### - Port forwarding -  

- [x] `docker run -e POSTGRES_PASSWORD=pass -e POSTGRES_USER=postgres -p 5434:5432 postgres` - **Запускает контейнер с образом PostgreSQL**

> `-p 5434:5432` — *маппинг портов между хостом и контейнером:*  
>
>>5434 — порт на хосте (локальной машине), через который можно будет подключаться к базе данных PostgreSQL.  
>>5432 — порт внутри контейнера, который используется по умолчанию для PostgreSQL.
> 
>> * База данных в контейнере будет доступна на порту 5434 локальной машины.
>> * Этот контейнер будет запускаться с PostgreSQL сервером, готовым для подключения через порт 5434 на хосте.  

- [x] `ifconfig en0` - **Отображает сетевую информацию интерфейса en0 на системах macOS**  

- [x] `docker run -it --rm --privileged --pid=host justincormack/nsenter1` - **Запускает контейнер с привилегированным доступом и позволяет выполнять команды в пространстве процессов хоста**  

> `--rm` — автоматически удаляет контейнер после завершения его работы. Это полезно для временных контейнеров, чтобы они не засоряли систему.
>
> `--privileged` — предоставляет контейнеру повышенные привилегии, что позволяет ему выполнять действия,  
обычно запрещённые в стандартных контейнерах, такие как доступ к устройствам хоста и работа с пространствами имён.
>
> `--pid=host` — позволяет контейнеру использовать PID namespace хоста. Это значит, что контейнер будет видеть и взаимодействовать с процессами хостовой системы.
>
> `justincormack/nsenter1` — это образ контейнера, который включает в себя инструмент nsenter.  
Этот инструмент позволяет входить в пространство имён (namespace) других процессов. В данном случае используется для входа в пространство имён процессов хоста.  

### - Host Driver -

- [x] `docker run -it -d --network host --name alpine1 alpine:latest sh` - **Запускает контейнер с использованием сети хоста**  

>**Host driver в Docker** — это один из сетевых драйверов, который позволяет контейнеру использовать сеть хоста напрямую,  
>без создания собственной виртуальной сети. Это означает, что контейнер и хост будут работать в одном и том же сетевом пространстве,  
>что даёт контейнеру доступ ко всем сетевым интерфейсам и IP-адресам хоста.
>
>>**Особенности host driver:**
>>1. **Общие сетевые интерфейсы:**  
>>Контейнер использует те же сетевые интерфейсы, что и хостовая машина.  
>>Нет дополнительного уровня изоляции для контейнеров по сравнению с другими сетевыми драйверами, такими как bridge.
>>
>>2. **Отсутствие виртуализации сети:**  
>>В отличие от драйвера bridge, который создаёт виртуальную сеть для контейнеров,  
>>host драйвер устраняет необходимость в NAT (Network Address Translation). Все порты и IP-адреса, доступные хосту, будут доступны и контейнеру.  
>>
>>3. **Поведение портов:**  
>>При использовании host driver флаг -p для проброса портов не требуется.  
>>Порты контейнера и хоста уже синхронизированы, так как они используют одно и то же сетевое пространство.  
>
>**Когда использовать host driver:**
>>* **Производительность:** Этот драйвер может быть полезен в случаях, когда критична производительность сети,  
>>так как контейнеру не нужно проходить через уровни виртуализации.  
>>* **Сетевые сервисы:** Подходит для контейнеров, которые работают с сетевыми сервисами (например, DNS, DHCP),  
>>где доступ к реальной сети хоста необходим.   
>
>**Ограничения:**
>>* **Безопасность:** Поскольку контейнер делит сетевое пространство с хостом, это снижает уровень изоляции контейнера и увеличивает риски безопасности.
>>* **Ограниченное применение:** Подходит только для Linux-хостов. На Windows и MacOS host driver работает по-другому или не поддерживается так же полноценно, как на Linux.  

### - None Driver -

- [x] `docker run -it -d --network none --name alpine2 alpine:latest sh` - **Запускает без доступа к сети**   

>**None driver в Docker** — это сетевой драйвер, который используется для создания контейнера без какой-либо сетевой конфигурации.  
Когда контейнер запускается с драйвером none, у него нет доступа к сети, и сетевой стек контейнера не будет настроен.  
>> **Когда использовать None driver:**
>>* **Изолированные вычисления:** Если контейнер не нуждается в сетевых взаимодействиях, например, для выполнения чисто вычислительных  
>>задач или обработки данных, none — это отличный способ минимизировать поверхность атаки и снизить риски безопасности.
>>* **Тестирование:** Полезно для тестирования контейнеров в изолированной среде, когда сетевые взаимодействия не нужны или нежелательны.
---

## Building images

- [x] `docker build --build-arg alpine_version=3 -f Dockerfile .` - **Запускает build**

>ARG alpine_version=latest  
>FROM alpine:${alpine_version} AS base  
>
>WORKDIR /  
>WORKDIR app  
>WORKDIR build  
>
>RUN touch test.txt && echo "Hello World" >> test.txt  
>RUN cd .. \  
>&& wget https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.30/bin/apache-tomcat-10.1.30.tar.gz \  
>&& tar -xvzf apache-tomcat-10.1.30.tar.gz \  
>&& rm apache-tomcat-10.1.30.tar.gz  
>
>COPY text.txt /app  
>#ADD text.txt /app  
>
>FROM alpine:latest  
>
>RUN apk add openjdk17  
>
>COPY --from=base /app/text.txt /app/text.txt  
>
>EXPOSE 8080  
>ENTRYPOINT ["app/apache-tomcat-10.1.30/bin/catalina.sh"]  
>CMD ["run"]   


В Dockerfile, директивы WORKDIR, RUN и COPY используются для определения действий и настроек,  
которые будут применены во время сборки Docker-образа. Вот подробное описание каждой из этих инструкций:

### - WORKDIR -

>**WORKDIR** задает рабочую директорию внутри контейнера. Если эта директория не существует, она будет создана.  
>Все команды, которые будут выполняться после этой инструкции, будут работать в контексте этой директории,  
>пока не будет вызвана новая команда WORKDIR.
>
>Пример:
> 
>>WORKDIR /app  
>
>*Теперь все команды, которые идут после WORKDIR, будут выполняться внутри директории **/app**.*  

### - RUN -

>**RUN** выполняет команду в процессе сборки образа и фиксирует результат в новом слое файловой системы.  
>Обычно RUN используется для установки зависимостей, установки пакетов и выполнения других команд,  
>которые необходимо выполнить один раз во время сборки.
>
>Пример:  
>
>>RUN apt-get update && apt-get install -y curl  
>
>*В этом примере команда обновляет списки пакетов и устанавливает утилиту **curl**.  
>Результат выполнения команды сохраняется в виде нового слоя в образе.*  

### - COPY -

>**COPY** копирует файлы и каталоги из контекста сборки (вашей локальной файловой системы) в файловую систему контейнера.  
>Эта команда копирует файлы с вашего компьютера в контейнер на этапе сборки.
>
>Пример:  
>
>>COPY ./src /app  
>
>*Этот пример копирует содержимое папки src на вашем компьютере в директорию **/app** в контейнере.*
> 
>**В Dockerfile команды `ADD` и `COPY` служат для копирования файлов в контейнер, но между ними есть несколько отличий:**  
>
>Основная разница:
>>`COPY` — это более простая и предсказуемая команда, предназначенная для копирования файлов или директорий из контекста сборки (с локальной файловой системы) в контейнер.  
>>`ADD` — расширенная версия команды, которая помимо копирования файлов может:  
>>* Распаковывать архивы (например, .tar файлы) при копировании.  
>>* Копировать файлы с удаленных URL-адресов (например, через HTTP/HTTPS).   

### - ENTRYPOINT и CMD -

>**ENTRYPOINT** и **CMD** в Dockerfile оба используются для указания команд, которые будут выполняться при запуске контейнера,  
>но между ними есть ключевые отличия:
>
>>1. **Основное назначение:**
>>* `CMD`: Указывает команду по умолчанию, которая будет выполнена, если при запуске контейнера не будет указана другая команда.  
>>Если вы запускаете контейнер с другой командой, она заменит команду, заданную в `CMD`.
>>* `ENTRYPOINT`: Указывает команду, которая всегда будет выполняться при запуске контейнера,  
>>независимо от переданных аргументов. Аргументы к этой команде можно добавить при запуске контейнера.  
>>2. **Замена команды:**
>>* `CMD` можно легко заменить при запуске контейнера, передав новую команду.
>>* `ENTRYPOINT` нельзя заменить, но можно передать дополнительные аргументы, которые будут добавлены к команде, указанной в `ENTRYPOINT`.
>>3. **Совместное использование:**
>>* `CMD` может быть использован для задания аргументов по умолчанию для `ENTRYPOINT`.  
>>Например, `ENTRYPOINT` задает программу, а `CMD` — аргументы для этой программы.  

### - Image Tapping -

**При работе с Docker можно использовать следующие команды для управления образами:**

>1. **Создание образа:**
>
>>`docker build -t my-image .`
>
>2. **Проверка существующих образов:**
>
>>`docker images`
>
>3. **Удаление неиспользуемых образов:**
>
>>`docker image prune`
>
>4. **Обновление образа:**
>
>>`docker pull my-image:latest`  

### - docker tag -

**Команда docker tag используется для создания меток (тегов) для образов Docker.  
Это позволяет вам назначать дополнительные имена и версии образам, что упрощает их управление и использование.  
Теги являются важной частью семантики Docker и помогают в управлении версиями и развертывании приложений.**

>Примеры  
>
>**Создание тега для существующего образа:**  
>
>>`docker tag my-image:latest my-image:v1.0`  
> 
>*В этом примере образ my-image с тегом latest помечается как my-image:v1.0.*  
> 
>**Создание тега для образа с использованием ID:**  
> 
>>`docker tag 123abc456def my-image:latest`  
> 
> **Тегирование образа для загрузки в реестр:**  
>
>>`docker tag my-image myrepo/my-image:latest`
> 
>*Этот пример подготавливает образ my-image для загрузки в репозиторий myrepo, назначая ему тег latest.*

### - local registry -

Локальный реестр (local registry) в контексте Docker — это сервер, который позволяет хранить и управлять Docker-образами в локальной сети.  
Он может быть полезен для разработки, тестирования и развертывания приложений без необходимости использовать внешний реестр, такой как Docker Hub.  
Использование локального реестра позволяет быстрее загружать и выгружать образы, а также обеспечивает контроль над доступом к ним.  

>**Настройка локального реестра**  
>
>1. **Запуск локального реестра:** Docker предоставляет официальный образ для создания локального реестра.  
>Чтобы запустить его, используйте следующую команду:
>
>>`docker run -d -p 5000:5000 --name registry registry:2`
>
>*Это создаст и запустит локальный реестр на порту 5000.*
>
>2. **Проверка работы реестра:** После запуска реестра вы можете проверить его работу,  
>открыв веб-браузер и перейдя по адресу http://localhost:5000/v2/.  
>Вы должны увидеть ответ JSON, подтверждающий, что реестр работает.    
>  
>3. **Тегирование образа для локального реестра:** Перед тем как загрузить образ в локальный реестр, его нужно тегировать.  
>Например:
>
>>`docker tag my-image localhost:5000/my-image`
>
>4. **Загрузка образа в локальный реестр:** После тегирования вы можете загрузить образ в реестр:
>
>>`docker push localhost:5000/my-image`
>
>5. **Загрузка образа из локального реестра:** Чтобы загрузить образ из локального реестра, используйте команду:
>
>>`docker pull localhost:5000/my-image`   
>
>**Преимущества использования локального реестра**
>* **Скорость:** Локальный реестр может обеспечить более быструю загрузку и выгрузку образов, особенно если у вас ограниченная пропускная способность интернета.
>* **Контроль доступа:** Вы можете настроить аутентификацию и авторизацию для управления доступом к образам.
>* **Изоляция:** Использование локального реестра позволяет изолировать ваши образы от внешнего мира, что может повысить безопасность.

### - Практика -

>V1  
>FROM alpine:latest  
>
>RUN apk add git openjdk17  
>
>RUN git clone https://github.com/dmdev2020/spring-starter.git  
>WORKDIR spring-starter  
>RUN git checkout lesson-125  
>RUN ./gradlew bootJar  
>RUN cp build/libs/spring-starter-*.jar ./service.jar  
>
>COPY application-dev.yaml .  
>
>EXPOSE 8080  
>ENTRYPOINT ["java", "-jar", "service.jar"]  
>CMD ["--spring.config.location=classpath:/application.yml,file:application-dev.yaml"]  
  
>V2  
>FROM alpine:latest AS base  
>
>RUN apk add git openjdk17  
>
>RUN git clone https://github.com/dmdev2020/spring-starter.git  
>WORKDIR spring-starter  
>RUN git checkout lesson-125 && ./gradlew bootJar  
>
>FROM alpine:latest AS result  
>
>RUN apk add openjdk17  
>
>WORKDIR /app  
>COPY --from=base /spring-starter/build/libs/spring-starter-*.jar ./service.jar  
>
>COPY application-dev.yaml .  
>
>EXPOSE 8080  
>ENTRYPOINT ["java", "-jar", "service.jar"]  
>CMD ["--spring.config.location=classpath:/application.yml,file:application-dev.yaml"]  
  

`docker build -f Dockerfile .`  
`docker run -e POSTGRES_PASSWORD=pass -e POSTGRES_USER=postgres -d --name postgres postgres`  
`docker network create practice_net`  
`docker network connect practice_net postgres`  
`docker run --name web --network practice_net 71b96bd673c797`  
---

##  Docker Compose

**Основные команды с описанием**  

- [x] `docker compose up` — Запускает все сервисы, описанные в файле `docker-compose.yml`. Если образы еще не существуют,  
они будут созданы. Контейнеры запускаются в фоновом режиме, если используется флаг `-d (detached mode)`.

- [x] `docker compose down` — Останавливает и удаляет контейнеры, созданные с помощью `docker-compose up`, а также сети и тома,  
если указаны соответствующие опции.

- [x] `docker compose build` — Создает или пересобирает образы для всех сервисов, описанных в файле `docker-compose.yml`.  
Флаг `--no-cache` отключает использование кеша при сборке.

- [x] `docker compose start` — Запускает уже созданные контейнеры (которые были остановлены), не пересоздавая их.

- [x] `docker compose stop` — Останавливает работающие контейнеры, но не удаляет их.

- [x] `docker compose restart` — Перезапускает контейнеры, если они уже созданы.

- [x] `docker compose logs` — Отображает логи для всех сервисов в реальном времени.  
Можно указать конкретный сервис для просмотра его логов, например: `docker-compose logs service_name`.

- [x] `docker compose ps` — Показывает информацию о запущенных контейнерах, включая статус и имена контейнеров.

- [x] `docker compose exec` — Выполняет команду в уже запущенном контейнере.  
Например, чтобы получить доступ в контейнер с помощью оболочки: `docker-compose exec service_name /bin/sh`.

- [x] `docker compose run` — Запускает одноразовый контейнер на основе сервисов, описанных в `docker-compose.yml`.  
В отличие от `up`, команда `run` не сохраняет состояние контейнера после завершения работы.

- [x] `docker compose config` — Проверяет файл `docker-compose.yml` на синтаксические ошибки и выводит его с применением всех переменных окружения.

- [x] `docker compose pull` — Загружает образы из Docker Hub или другого реестра, не создавая контейнеры.

- [x] `docker compose kill` — Прерывает (отправляет сигнал SIGKILL) все запущенные контейнеры, описанные в `docker-compose.yml`.

- [x] `docker compose rm` — Удаляет остановленные контейнеры. Можно использовать с флагом `-f` для принудительного удаления без подтверждения.

- [x] `docker compose scale` — Масштабирует количество запущенных контейнеров для указанного сервиса.  
Например: `docker-compose scale web=3` создаст три контейнера для сервиса web.  

>name: myapp  
>  
>>services:  
>>first:  
>>image: alpine:latest  
>>command: ["top"] #CMD  
>>networks:  
>>- frontend  
>  
>>database:  
>>image: postgres:latest  
>>ports:  
>>- "5435:5432"  
>>environment:  
>>- POSTGRES_PASSWORD_FILE=run/secrets/postgres_password  
>>- POSTGRES_USER=postgres  
>>networks:  
>>- backend  
>>volumes:  
>>- db-data:/var/lib/postgresql/data  
>>secrets:  
>>- postgres_password  
>  
>  
>>web:  
>>image: myapp-web  
>>environment:  
>>- SPRING_DATASOURCE_URL=jdbc:postgresql://database:5432/postgres  
>>build:  
>>context: .  
>>dockerfile: Dockerfile  
>>networks:  
>>- backend  
>>- frontend  
>  
>>networks:  
>>backend:  
>>driver: bridge  
>>frontend:  
>>driver: bridge  
>  
>>volumes:  
>>db-data:  
>  
>>secrets:  
>>postgres_password:  
>>file: ./secrets.txt  










































   













