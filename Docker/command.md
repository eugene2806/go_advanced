## Команды Docker

[Создание контейнера](#создание-контейнера)  
[Запуск контейнера](#запуск-контейнера)  
[Остановка контейнера](#остановка-контейнера)  
[Удаление контейнера](#удаление-контейнера)  
[Временная остановка контейнера (pause)](#временная-остановка-контейнера)  
[Start и Restart контейнера](#start-и-restart-контейнера)  
[Выполнение bash команд внутри контейнера (exec)](#выполнение-bash-команд-внутри-контейнера)  
[Перенос файлов в контейнер и на локальную машину (cp, diff)](#перенос-файлов-в-контейнер-и-на-локальную-машину)  
[Типы монтирования в Docker: bind, volume и tmpfs](#типы-монтирования-в-docker-bind-tmpfs-и-volume)





### Создание контейнера

* `docker create alpine:latest` - **Создает image**

* `docker images` - **Показывает все images**

* `docker ps` - **Показывает запущенные контейнеры**

* `docker ps -a` - **Показывает все контейнеры**

* `docker inspect 7b7b86ce581f` - **Показывает информацию о контейнере**


### Запуск контейнера

* `docker start 7b7b86ce581f` - **Запускает контейнер**


### Остановка контейнера

* `docker stop 7b7b86ce581f` - **Останавливает контейнер**


*Механизм: При использовании команды docker stop, контейнеру сначала посылается сигнал SIGTERM,  
который даёт процессу внутри контейнера возможность корректно завершиться. Если процесс не завершится  
в течение определённого времени (по умолчанию — 10 секунд), Docker отправит сигнал SIGKILL,  
который принудительно завершит процесс.*

*Цель: Остановка контейнера мягким способом, предоставляя приложению время на выполнение завершающих операций  
(например, завершение активных запросов, сохранение данных и т.д.).*

* `docker kill 7b7b86ce581f` - **Останавливает контейнер сразу**

*Механизм: Команда docker kill моментально отправляет контейнеру сигнал SIGKILL, что немедленно завершает процесс.  
В этом случае приложение не получает времени на корректное завершение, оно просто мгновенно останавливается.*  

*Цель: Принудительное завершение работы контейнера, если нужно быстро его остановить или если docker stop не сработал.*


### Удаление контейнера

* `docker rm (-f) 7b7b86ce581f` - **Удаляет контейнер. -f Остонавливает и удаляет контейнер**


### Временная остановка контейнера

* `docker pause 7b7b86ce581f` - **Временно останавливает контейнер для освобождения ресурсов CPU**

* `docker unpause 7b7b86ce581f` - **Запускает остановленный контейнер**

* `docker logs 7b7b86ce581f` - **Показывает логи контейнера**

* `docker stats --no-stream` - **Показывает ресурсы выделяемые под контейнеры**


### Start и Restart контейнера

#### - Run -
* `docker run -e POSTGRES_PASSWORD=pass postgres` - **Выполняет create + start команды (нет ввода)**

***Основные флаги для docker run***

1. `-d, --detach:` Запускает контейнер в фоновом режиме (detached mode), возвращая управление терминалу.  
`docker run -e POSTGRES_PASSWORD=pass -d postgres` - **Выполняет create + start команды (есть ввод команд)**  
2. `-it:` Объединение двух флагов:  
-i, --interactive: Поддерживает стандартный ввод (stdin), чтобы контейнер оставался активным для ввода команд.  
-t, --tty: Создаёт псевдотерминал, что удобно для запуска интерактивных приложений.  
3. `--env, -e:` Передаёт переменные окружения в контейнер.
4. `-p, --publish:` Пробрасывает порты из контейнера на хост-машину.  
Формат: хостовый_порт:порт_контейнера. `docker run -p 8080:80 nginx`

#### - Restart -   
* `docker restart (-t, --time) 7b7b86ce581f` - **Перезапускает контейнер. -t, --time время ожидания перед перезапуском**

***Варианты политики перезапуска:***  
`docker run --restart=always my_container`

1. `no` (по умолчанию): Docker не будет автоматически перезапускать контейнер.  
2. `always:` Docker всегда будет перезапускать контейнер, если он остановлен, независимо от причины.  
Контейнер также будет перезапускаться после перезапуска хоста Docker.   
3. `on-failure[:max-retries]:` Docker перезапустит контейнер только в случае, если он завершился с ошибкой  
(ненулевой код выхода). Можно указать максимальное количество попыток перезапуска.  
Пример: **on-failure:5** — перезапустит контейнер до 5 раз, если он завершился с ошибкой.
4. `unless-stopped:` Контейнер будет перезапущен всегда, кроме случая, когда его явно остановили.  
После перезапуска хоста Docker контейнер также будет перезапущен.


### Выполнение bash команд внутри контейнера

* `docker exec 7b7b86ce581f ls` - **Выполнит команду ls внутри контейнера**
* `docker exec 327 which sh(bash)` - **Проверяет установленные оболочки**

***Основные флаги для docker exec***

1. `-i, --interactive:` Оставляет стандартный ввод (stdin) открытым, чтобы взаимодействовать с процессом.  
Это позволяет передавать команды в контейнер в реальном времени.  
`docker exec -i 327 sh` - **Передает команды в оболочку shell в контейнере**
2. `-t, --tty:` Создаёт псевдотерминал (tty), что особенно полезно для работы с интерактивными программами  
(например, запуском shell сессии). Часто используется с флагом -i для интерактивного сеанса.  
`docker exec -it 327 sh` - **Создаст терминал для работы в контейнере**  
`docker run -it alpine sh` - **Запустит контейнер сразу вызвав терминал**


### Перенос файлов в контейнер и на локальную машину

* `docker cp copy_test 7b7b86ce581f:/` - **Копирование папки из корня на локальной машине в корень контейнера**

* `docker cp 7b7b86ce581f:/copy_test/copy.txt copy.txt  ` - **Копирование файла из папки контейнера в корень на локальной машине**

* `docker diff 7b7b86ce581f` - **Показывает все изменения в контейнере**


### Типы монтирования в Docker: bind, tmpfs и volume

#### - Bind -

* `docker run -it --mount type=bind,source="$(pwd)"/copy_test,target=/app alpine sh` - **Монтирует каталог или файл с хостовой машины в контейнер**

Флаг `--mount type=bind` в Docker используется для монтирования каталога или файла с хостовой машины (твоего компьютера)  
в контейнер. Это позволяет контейнеру работать с файлами и директориями на хосте так, как будто они находятся внутри контейнера.

1. *type=bind: Указывает, что используется bind-монтирование (прямое связывание директории/файла с хоста в контейнер).*
2. *source: Путь к директории или файлу на хосте, который ты хочешь смонтировать.*
3. *target: Путь внутри контейнера, куда будет смонтирован источник с хоста.*   

#### - Tmpfs -

* `docker run -it --mount type=tmpfs,target=/temp,tmpfs-size=16k,tmpfs-mode=1777 alpine sh` - **Запускает контейнер Docker с временной файловой системой (tmpfs)**  

***Разбор компонентов:***  

1. `docker run:` *Команда для создания и запуска контейнера.*
2. `-it:`
* **-i (interactive):** Оставляет стандартный ввод (stdin) контейнера открытым для взаимодействия.  
* **-t (tty):** Создаёт терминал (TTY) для интерактивного сеанса.

3. `--mount type=tmpfs:` *Указывает, что будет использоваться временная файловая система (tmpfs).*    
Это означает, что данные будут храниться в оперативной памяти, и они будут потеряны при остановке контейнера.

4. `target=/temp:` *Указывает, что временная файловая система будет смонтирована в контейнере по пути /temp.*
* 5tmpfs-size=16k: Устанавливает размер временной файловой системы в 16 килобайт.    
Это ограничение на объём памяти, который может быть использован для хранения данных в этой файловой системе.

6. `tmpfs-mode=1777:` *Устанавливает права доступа для монтируемой временной файловой системы.*    
Значение 1777 соответствует правам доступа rwxrwxrwt, что означает:

* **rwx:** Чтение, запись и выполнение для владельца.
* **rwx:** Чтение, запись и выполнение для группы.
* **rwx:** Чтение, запись и выполнение для всех остальных.
* **t:** Установка бита "sticky", который позволяет только владельцу файла удалять или изменять его.

7. `alpine sh:` *Указывает, что будет использоваться образ Alpine, и запускает в контейнере командную оболочку sh.*  

#### - Volume -

* `  docker run -it --mount type=volume,source=postgresql-data,target=/data alpine sh` - **Запускает контейнер Docker с использованием тома (volume) для хранения данных**  

***Разбор компонентов:***   

1. `docker run -it:` *Создает и запускает новый контейнер в интерактивном режиме с TTY (терминалом).*  

2. `--mount type=volume,source=postgresql-data,target=/data:`

* **type=volume:** Указывает, что мы используем том (volume) для монтирования.  
* **source=postgresql-data:** Имя тома, который будет создан или использован. Если тома с таким именем ещё не существует, Docker создаст его.  
* **target=/data:** Путь внутри контейнера, по которому будет смонтирован том. Все данные, записанные в /data внутри контейнера, будут храниться в томе postgresql-data.  

3. `alpine sh:` *Использует образ Alpine и запускает командную оболочку sh внутри контейнера.*

#### Команды для удаления volume

* `docker volume rm postgresql-data` - **Удаляет volume postgresql-data**  
* `docker volume rm prune` - **Удаляет неиспользуемые volume**  

#### Зачем использовать тома?

1. **Долговременное хранение:**

- Данные, сохраненные в /data, останутся доступными даже после остановки и удаления контейнера.  
Это идеально подходит для хранения данных баз данных, конфигураций и других важных файлов.  

2. **Изоляция данных:**

- Использование томов позволяет изолировать данные от жизненного цикла контейнера.  
Ты можешь создавать и удалять контейнеры без потери данных.  

3. **Обмен данными между контейнерами:**

- Если у тебя несколько контейнеров, которые должны работать с одними и теми же данными, они могут использовать один и тот же том.  
Это упрощает обмен данными между различными сервисами.  

**Пример использования:**  

*Хранение данных PostgreSQL: Если ты собираешься использовать этот контейнер для PostgreSQL,   
ты можешь запустить PostgreSQL в контейнере и настроить его так, чтобы он хранил все свои данные в /data.   
Все данные будут сохраняться в томе postgresql-data, и ты сможешь использовать его повторно в других контейнерах, если потребуется.*











   













